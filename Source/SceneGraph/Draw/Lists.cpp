
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2009, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  List of lists of draw elements.
//
///////////////////////////////////////////////////////////////////////////////

#include "SceneGraph/Draw/Lists.h"

#include "Usul/Functions/NoThrow.h"

using namespace SceneGraph::Draw;


///////////////////////////////////////////////////////////////////////////////
//
//  Typedefs with file scope.
//
///////////////////////////////////////////////////////////////////////////////

typedef Usul::Threads::Guard<Usul::Threads::Mutex> Guard;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Lists::Lists() : BaseClass(),
  _elementLists()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Lists::~Lists()
{
  USUL_TRY_BLOCK
  {
    _elementLists.clear();
  }
  USUL_DEFINE_CATCH_BLOCKS ( "3091334843" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the element.
//
///////////////////////////////////////////////////////////////////////////////

void Lists::append ( int key, Element::RefPtr element )
{
  if ( true == element.valid() )
  {
    Guard guard ( _elementLists.mutex() );
    ElementLists &els ( _elementLists.getReference() );
    ElementList &el ( els[key] );
    el.push_back ( element );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear all the lists.
//
///////////////////////////////////////////////////////////////////////////////

void Lists::clear ( bool deleteMemory )
{
  // Get the map.
  Guard guard ( _elementLists.mutex() );
  ElementLists &els ( _elementLists.getReference() );

  // If we're supposed to delete all the memory...
  if ( true == deleteMemory )
  {
    els.clear();
  }

  // Otherwise, clear each individual vector.
  else
  {
    for ( ElementLists::iterator i = els.begin(); i != els.end(); ++i )
    {
      i->second.clear();
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the number of elements for the key.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Lists::numElements ( int key ) const
{
  Guard guard ( _elementLists.mutex() );
  const ElementLists &els ( _elementLists.getReference() );
  ElementLists::const_iterator i ( els.find ( key ) );
  return ( ( els.end() != i ) ? i->second.size() : 0 );
}
